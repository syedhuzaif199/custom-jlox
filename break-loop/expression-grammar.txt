Productions:
expression  ->  literal
             |  unary
             |  binary
             |  grouping ;

literal     ->  NUMBER | STRING | "true" | "false" | "nil" ;

grouping    ->  "(" expression ")"  ;

unary       ->  ("-" | "!") expression  ;

binary      ->  expression operator expression  ;

operator    ->  "==" | "!=" | "<" | "<=" | ">" | ">="
             |  "+"  | "-"  | "*" | "/" ;


Example derivations:

1. 1 + -3

expression
    => binary
    => expression operator expression
    => literal operator expression
    => "1" operator expression
    => "1" "+" expression
    => "1" "+" unary
    => "1" "+" "-" expression
    => "1" "+" "-" literal
    => "1" "+" "-" "3"

********************************************

Revised Grammar for precedence

expression      ->  equality

equality        ->  comparison ( ( "==" | "!=" ) comparison)* ;

comparison      ->  term ( ( "<" | "<=" | ">" | ">=" ) term)* ;

term            ->  factor ( ( "+" | "-" ) factor )* ;

factor          ->  unary ( ( "/" | "*" ) unary )* ;

unary           ->  ( "!" | "-" ) unary
                 |  primary  ;

primary         ->  NUMBER | STRING | "true" | "false" | "nil" 
                 |  "(" expression ")" ;

********************************************

Grammar including statements

program         ->  declaration* EOF ;

declaration     ->  varDecl | statement ;

varDecl         ->  "var" IDENTIFIER ( "=" expression )? ";" ;

statement       ->  exprStmt | forStmt | ifStmt | printStmt | whileStmt | block ;

forStmt         ->  "for" "(" ( varDecl | exprStmt | ";" ) expression? ";" expression ")" statement;

whileStmt       -> "while" "(" expression ")" statement ;

ifStmt          ->  "if" "(" expression ")" statement
                    ( "else" statement )? ;

block           ->  "{" declaration* "}" ;

exprStmt        ->  expression ";" ;

printStmt       ->  "print" expression ";" ;

expression      ->  assignment  ;

assignment      ->  IDENTIFIER "=" assignment 
                 |  logic_or ;

logic_or        -> logic_and ( "or" logic_and )* ;

logic_and       -> equality ( "and" equality)* ;

equality        ->  comparison ( ( "==" | "!=" ) comparison)* ;

comparison      ->  term ( ( "<" | "<=" | ">" | ">=" ) term)* ;

term            ->  factor ( ( "+" | "-" ) factor )* ;

factor          ->  unary ( ( "/" | "*" ) unary )* ;

unary           ->  ( "!" | "-" ) unary
                 |  primary  ;

primary         ->  NUMBER | STRING | "true" | "false" | "nil" 
                 |  "(" expression ")" 
                 |  IDENTIFIER ;
